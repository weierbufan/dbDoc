## 查询性能优化
前面我们介绍了如何设计最优的库表结构，如何建立最好的索引，这些对于高性能来说是必不可少的。但这些还不够--还需要合理的设计查询。如果查询写的糟糕，即使库表结构在合理，索引在合适，也无法实现高性能。
### 6.1 为什么查询速度会慢
### 6.2 慢查询优化基础：优化数据访问
#### 6.2.1 是否向数据库请求了不需要的数据
#### 6.2.2 mysql是否在扫描额外的记录
### 6.3 重构查询的方式
在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果--而不是总是需要从MySQL获取一模一样的结果集。有时候，可以将查询换一种写法让其返回一样的结果集，但性能更好。但也可以通过修改代码通过另一种方式来达到目的。
#### 6.3.1 一个复杂查询还是多个简单查询
#### 6.3.2 切分查询
#### 6.3.3 分解关联查询
很多高性能应用都会对关联查询进行分解。简单地，可以对每个表进行一次单表查询，然后将结果在应用程序中做关联。事实上通过分解关联查询的方式来重构查询有如下又是：
* 让缓存的效率更高：许多应用程序可以方便的缓存单表查询对应的结果对象（例如使用应用程序本身的来缓存或者使用缓存工具）。另外，对mysql的查询缓存来说，
如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少变化，那么基于该表的查询就可以重复利用查询缓存结果了。
* 将查询拆分后，执行单个查询可以减少锁的竞争。（防止出现死锁，所等待等的消耗）
* 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
* 查询本身的效率也可能提升。在这儿例子中，使用**IN()** 来代替关联查询，可以让mysql可以按照ID顺序进行查询，这可能比随机的关联更高效。
* 可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复的访问一部分数据。
* 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用mysql的嵌套循环关联。某些场景哈希关联的效率要高的多。
在很多场景下，通过查询重构将关联放在应用程序中将会更加高效，这样的场景很多，比如：当应用可以方便的缓存单个结果的时候，当可以将数据分布到不同的mysql服务器的时候，当能够使用IN()的方式代替关联查询的时候，当查询中使用到同一个表的时候。
