## zset中在相同score下相关排名问题
1. 需求

Redis 提供了按分数进行排序的有序集合。 比如在游戏里面，比如战斗力排行，充值排行，用默认的Redis 实现就可以达到需求。

但是，比如等级排行，大家都是30级，谁先到30级谁第一。Redis 默认实现是，相同分数的成员按字典顺序排序（0 ~9 ， A ~Z，a ~ z），所以相同分数排序就不能根据时间优先来排序。

需要设计一个 【分数 = 等级 + 时间】 ，谁分数大谁第一，最后再根据分数能解析出来等级即可。

2.设计

分数 = 等级 + 时间 （当前系统时间戳）

分数是 64位的长整型 Long (有符号)

1) 设计方式一

long 分数，二进制用高 32位存 等级，低32位存时间（秒精度），那么数据看起是这样

A 玩家， 10 + 1111111111（时间戳）

后来 B 玩家也到 10 级， 10 + 2222222222（时间戳）

这样排序，最终还是 B 玩家 会排到第一名，不能达到目的。

2) 设计方式二

long 整数长度总共有 19位，923XXX.......，时间戳 毫秒精度 是 13位，所以只需 14 ~ 19 位存 等级，其他13位存时间。接下来看怎么存。

等级偏移： Math.power(10, 14) = 10000000000000000（14位）

这里有一个最大时间 MAX_TIME = 9999999999999 （13位）

A 玩家，（10 * 等级偏移） + MAX_TIME - 11111111111111（ 时间戳），最终分数 10888888888888888

B 玩家，（10 * 等级偏移） + MAX_TIME - 22222222222222（ 时间戳），最终分数 10777777777777777

最终排序，A 玩家依然是第一。通过分数可以解析出真实 【等级 = 分数 / 等级偏移，取整】

3. 劣势

1) 如果有三个，四个排序条件怎么办，这种情况还是推荐使用数据库，就别考虑 Redis了 。Redis 优势在于可以做到实时排行

2) 方式二 14 ~ 19位，那么等级最大数据就只能是 919999，超过这个数就会溢出。可以把时间戳降低到秒级别，可以支持更大数字

4. 总结

以上设计主要还是针对游戏内排行榜，并不能涵盖所有行业，只能说是借鉴作用，仅供参考。

参考：
* https://blog.csdn.net/zeus_9i/article/details/51025175
* https://blog.csdn.net/superit401/article/details/82629751
* https://www.cnblogs.com/mumuxinfei/p/5337329.html
