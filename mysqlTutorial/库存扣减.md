## 库存扣多了，到底怎么整
文中沈老师只说了幂等性的操作，下面的很多评论也是很赞的。
### 文章正文
![架构](https://github.com/weifansym/dbDoc/blob/master/images/mysql/set001.png)
业务复杂、数据量大、并发量大的业务场景下，典型的互联网架构，一般会分为这么几层：
* 调用层，一般是处于端上的browser或者APP
* 站点层，一般是拼装html或者json返回的web-server层
* 服务层，一般是提供RPC调用接口的service层
* 数据层，提供固化数据存储的db

对于库存业务，一般有个库存服务，提供库存的查询、扣减、设置等RPC接口：

![库存](https://github.com/weifansym/dbDoc/blob/master/images/mysql/set002.png)
* 库存查询，stock-service本质上执行的是：select num from stock where sid=$sid
* 库存扣减，stock-service本质上执行的是：update stock set num=num-$reduce where sid=$sid
* 库存设置，stock-service本质上执行的是：update stock set num=$num_new where sid=$sid

用户下单前，一般会对库存进行查询，有足够的存量才允许扣减：

![库存](https://github.com/weifansym/dbDoc/blob/master/images/mysql/set003.png)

如上图所示，通过查询接口，得到库存是5。

用户下单时，接着会对库存进行扣减：

![库存](https://github.com/weifansym/dbDoc/blob/master/images/mysql/set004.png)

如上图所示，购买3单位的商品，通过扣减接口，最终得到库存是2。

希望设计往往有容错机制，例如**“重试”，如果通过扣减接口来修改库存，在重试时，可能会得到错误的数据**，导致重复扣减：

![库存](https://github.com/weifansym/dbDoc/blob/master/images/mysql/set005.png)
如上图所示，如果数据库层面有重试容错机制，可能导致一次扣减执行两次，最终得到一个负数的错误库存。

重试导致错误的根本原因，是因为“扣减”操作是一个**非幂等的操作**，不能够重复执行，改成设置操作则不会有这个问题：

![库存](https://github.com/weifansym/dbDoc/blob/master/images/mysql/set006.png)
如上图所示，同样是购买3单位的商品，通过设置库存操作，即使有重试容错机制，也不会得到错误的库存，设置库存是一个幂等操作。

在并发量很大的情况下，还会有其他的问题：

![库存](https://github.com/weifansym/dbDoc/blob/master/images/mysql/set007.png)
如上图所示，两个并发的操作，查询库存，都得到了库存是5。

接下来用户发生了并发的购买动作（秒杀类业务特别容易出现）：

![库存](https://github.com/weifansym/dbDoc/blob/master/images/mysql/set008.png)
如上图所示：
* 用户1购买了3个库存，于是库存要设置为2
* 用户2购买了2个库存，于是库存要设置为3
* 这两个设置库存的接口并发执行，库存会先变成2，再变成3，导致数据不一致（实际卖出了5件商品，但库存只扣减了2，最后一次设置库存会覆盖和掩盖前一次并发操作）

其根本原因是，设置操作发生的时候，没有检查库存与查询出来的库存有没有变化，理论上：
* 库存为5时，用户1的库存设置才能成功
* 库存为5时，用户2的库存设置才能成功

实际执行的时候：
* 库存为5，用户1的set stock 2确实应该成功
* 库存变为2了，用户2的set stock 3应该失败掉

升级修改很容易，将库存设置接口，stock-service上执行的：
```
update stock set num=$y where sid=$sid
```
升级为：
```
update stock set num=$num_new where sid=$sid and num=$num_old
```
这正是大家常说的“Compare And Set”（CAS），是一种常见的降低读写锁冲突，保证数据一致性的方法。

总结
在业务复杂，数据量大，并发量大的情况下，库存扣减容易引发数据的不一致，常见的优化方案有两个：
* 调用“设置库存”接口，能够保证数据的幂等性
* 在实现“设置库存”接口时，需要加上原有库存的比较，才允许设置成功，能解决高并发下库存扣减的一致性问题
### 评论如下
> 这种方式在并发高的时候很容易出错，需要重试，最好把库存放到redis里，利用redis的原子性减操作这种方式在并发高的时候很容易出错，需要重试，
最好把库存放到redis里，利用redis的原子性减操作

> 我的做法是利用redis的单线程，请求来的时候先扣减库存，发现扣减后结果小于0，就回滚回去，如果大于0就就行业务处理，业务处理成功则ok业务处理不成功回滚，
这个请求在一个事务中

> 如果真的访问量大，通过rpc的方式是无论如何也不能解决问题的。当技术上实现有困难，或者不能实现时可以考虑对业务流程下手，让用户的下单行不要作为一个同步操作，
而是异步，对于用户来说，相当于提交了一个购买申请，到底是否购买成功，等会看系统反馈。对于系统实现，这个时候就简单了，把用户的下单申请放入队列，
由队列的消费端单线程做扣款操作，整个过程就不会有问题。

> 此类方场景经常遇到，常用的解决方法一般有两种，乐观锁和悲观锁。利用for update加id戓者其唯一索引实现悲观锁；戓者利用版本号等手段实现CAS类型的乐观锁。
但是这两种方案都有自己的缺点，悲观锁的吞吐率较低，在大并发的情况下容易产生两个问题，一个是大量的超时，包括数据库事务超时和业务接口超时；另一个是容易产
生死锁，死锁在账户类操作比较常见，比如两个事务同时对相同的两个账户互相转账，事务一：A转B，事务二：B转A，此时就会产生死锁。 而CAS类型的乐观锁在大并发
情况下会产生大量的失败，即数据库中某行数据的更新的影响行数为0，如使用失败重试机制来保证更新成功，又会带来其它的问题和风险。 不知道沈老师怎么解决上面的
两个矛盾？ 部分业务我们采用数据库的特性来解决，sql如下，update user_acc set amt = amt - 100 where uid = 123 and amt > 100； 利用数字类型
可直接计算的特性来赋值，而不是赋予一个事先计算好的值，这样解决并发量和死锁问题。 沈老师对这种方案怎么看呢？

> 作者说的两点优化，解决了一致性的问题，同时扣减操作具备幂等性。但是没有提到吞吐量，在高并发下可能支撑不住。在提高吞吐量上，个人有三点建议：
1.减少锁的时间。需要牺牲幂等性，整个扣减操作事务就是数据库本地操作，查询扣减和设置三步合成一步，中间没有网络请求。这样会增加几个数量级的吞吐量。 
2.利用缓存。缓存没有固化是不可靠的。可以通过写日志记录操作。写日志比写库快，尤其数据库热点数据。库存记录在缓存，更新数据同步写日志。
异步合并日志和更新。重启时缓存失效，读日志恢复。 
3.水平扩展。这是解决这个问题的根本方法。将库存分布于多个子节点，所有子节点库存之和为总库存。分布式会带来一系列问题，比如库存碎片，需要异步化零为整。
还有跨库事务问题等等。

> update stock set stock=stock-count where sid=$sid and stock>=count. 幂等的问题可以通过传入单号进行排重处理。传入单号也有利于库存对账

### 参考：
* https://www.w3cschool.cn/architectroad/architectroad-inventory.html
* [CAS与ABA问题](https://www.w3cschool.cn/architectroad/architectroad-cas-optimization.html)
